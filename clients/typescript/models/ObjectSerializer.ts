export * from './AccountBalanceRequest';
export * from './AccountBalanceResponse';
export * from './AccountBlockCountRequest';
export * from './AccountBlockCountResponse';
export * from './AccountGetRequest';
export * from './AccountGetResponse';
export * from './AccountHistoryRequest';
export * from './AccountHistoryResponse';
export * from './AccountInfoRequest';
export * from './AccountInfoResponse';
export * from './AccountKeyRequest';
export * from './AccountKeyResponse';
export * from './AccountRepresentativeRequest';
export * from './AccountRepresentativeResponse';
export * from './AccountWeightRequest';
export * from './AccountWeightResponse';
export * from './AccountsBalancesRequest';
export * from './AccountsBalancesResponse';
export * from './AccountsCreateRequest';
export * from './AccountsCreateResponse';
export * from './AccountsFrontiersRequest';
export * from './AccountsFrontiersResponse';
export * from './AccountsPendingRequest';
export * from './AccountsPendingResponse';
export * from './ActiveDifficultyRequest';
export * from './ActiveDifficultyResponse';
export * from './AvailableSupplyRequest';
export * from './AvailableSupplyResponse';
export * from './Block';
export * from './BlockAccountRequest';
export * from './BlockAccountResponse';
export * from './BlockConfirmRequest';
export * from './BlockConfirmResponse';
export * from './BlockCountRequest';
export * from './BlockCountResponse';
export * from './BlockCountTypeRequest';
export * from './BlockCountTypeResponse';
export * from './BlockCreateRequest';
export * from './BlockCreateResponse';
export * from './BlockDataJson';
export * from './BlockHashRequest';
export * from './BlockHashResponse';
export * from './BlockInfo';
export * from './BlockInfoRequest';
export * from './BlockInfoResponse';
export * from './BlockState';
export * from './BlocksInfoRequest';
export * from './BlocksInfoResponse';
export * from './BlocksRequest';
export * from './BlocksResponse';
export * from './BootstrapAnyRequest';
export * from './BootstrapAnyResponse';
export * from './BootstrapLazyRequest';
export * from './BootstrapLazyResponse';
export * from './BootstrapRequest';
export * from './BootstrapResponse';
export * from './ChainRequest';
export * from './ChainResponse';
export * from './Confirmation';
export * from './ConfirmationActiveRequest';
export * from './ConfirmationActiveResponse';
export * from './ConfirmationHeightCurrentlyProcessingRequest';
export * from './ConfirmationHeightCurrentlyProcessingResponse';
export * from './ConfirmationHistoryRequest';
export * from './ConfirmationHistoryResponse';
export * from './ConfirmationHistoryResponseConfirmationStats';
export * from './ConfirmationInfo';
export * from './ConfirmationInfoRequest';
export * from './ConfirmationInfoResponse';
export * from './KeyCreateRequest';
export * from './KeyCreateResponse';
export * from './KeyExpandRequest';
export * from './KeyExpandResponse';
export * from './ModelBoolean';
export * from './PendingBlock';
export * from './PendingRequest';
export * from './PendingResponse';
export * from './ProcessRequest';
export * from './ProcessResponse';
export * from './ReceiveRequest';
export * from './ReceiveResponse';
export * from './SubType';
export * from './WalletCreateRequest';
export * from './WalletCreateResponse';
export * from './WorkGenerateRequest';
export * from './WorkGenerateResponse';

import { AccountBalanceRequest, AccountBalanceRequestActionEnum    } from './AccountBalanceRequest';
import { AccountBalanceResponse } from './AccountBalanceResponse';
import { AccountBlockCountRequest, AccountBlockCountRequestActionEnum    } from './AccountBlockCountRequest';
import { AccountBlockCountResponse } from './AccountBlockCountResponse';
import { AccountGetRequest, AccountGetRequestActionEnum    } from './AccountGetRequest';
import { AccountGetResponse } from './AccountGetResponse';
import { AccountHistoryRequest, AccountHistoryRequestActionEnum     } from './AccountHistoryRequest';
import { AccountHistoryResponse } from './AccountHistoryResponse';
import { AccountInfoRequest, AccountInfoRequestActionEnum       } from './AccountInfoRequest';
import { AccountInfoResponse } from './AccountInfoResponse';
import { AccountKeyRequest, AccountKeyRequestActionEnum    } from './AccountKeyRequest';
import { AccountKeyResponse } from './AccountKeyResponse';
import { AccountRepresentativeRequest, AccountRepresentativeRequestActionEnum    } from './AccountRepresentativeRequest';
import { AccountRepresentativeResponse } from './AccountRepresentativeResponse';
import { AccountWeightRequest, AccountWeightRequestActionEnum    } from './AccountWeightRequest';
import { AccountWeightResponse } from './AccountWeightResponse';
import { AccountsBalancesRequest, AccountsBalancesRequestActionEnum    } from './AccountsBalancesRequest';
import { AccountsBalancesResponse } from './AccountsBalancesResponse';
import { AccountsCreateRequest, AccountsCreateRequestActionEnum     } from './AccountsCreateRequest';
import { AccountsCreateResponse } from './AccountsCreateResponse';
import { AccountsFrontiersRequest, AccountsFrontiersRequestActionEnum    } from './AccountsFrontiersRequest';
import { AccountsFrontiersResponse } from './AccountsFrontiersResponse';
import { AccountsPendingRequest, AccountsPendingRequestActionEnum       } from './AccountsPendingRequest';
import { AccountsPendingResponse } from './AccountsPendingResponse';
import { ActiveDifficultyRequest, ActiveDifficultyRequestActionEnum    } from './ActiveDifficultyRequest';
import { ActiveDifficultyResponse } from './ActiveDifficultyResponse';
import { AvailableSupplyRequest, AvailableSupplyRequestActionEnum   } from './AvailableSupplyRequest';
import { AvailableSupplyResponse } from './AvailableSupplyResponse';
import { Block } from './Block';
import { BlockAccountRequest, BlockAccountRequestActionEnum    } from './BlockAccountRequest';
import { BlockAccountResponse } from './BlockAccountResponse';
import { BlockConfirmRequest, BlockConfirmRequestActionEnum    } from './BlockConfirmRequest';
import { BlockConfirmResponse } from './BlockConfirmResponse';
import { BlockCountRequest, BlockCountRequestActionEnum    } from './BlockCountRequest';
import { BlockCountResponse } from './BlockCountResponse';
import { BlockCountTypeRequest, BlockCountTypeRequestActionEnum   } from './BlockCountTypeRequest';
import { BlockCountTypeResponse } from './BlockCountTypeResponse';
import { BlockCreateRequest, BlockCreateRequestActionEnum   , BlockCreateRequestTypeEnum           } from './BlockCreateRequest';
import { BlockCreateResponse } from './BlockCreateResponse';
import { BlockDataJson, BlockDataJsonTypeEnum           } from './BlockDataJson';
import { BlockHashRequest, BlockHashRequestActionEnum     } from './BlockHashRequest';
import { BlockHashResponse } from './BlockHashResponse';
import { BlockInfo } from './BlockInfo';
import { BlockInfoRequest, BlockInfoRequestActionEnum     } from './BlockInfoRequest';
import { BlockInfoResponse } from './BlockInfoResponse';
import { BlockState } from './BlockState';
import { BlocksInfoRequest, BlocksInfoRequestActionEnum     } from './BlocksInfoRequest';
import { BlocksInfoResponse } from './BlocksInfoResponse';
import { BlocksRequest, BlocksRequestActionEnum    } from './BlocksRequest';
import { BlocksResponse } from './BlocksResponse';
import { BootstrapAnyRequest, BootstrapAnyRequestActionEnum   } from './BootstrapAnyRequest';
import { BootstrapAnyResponse } from './BootstrapAnyResponse';
import { BootstrapLazyRequest, BootstrapLazyRequestActionEnum     } from './BootstrapLazyRequest';
import { BootstrapLazyResponse } from './BootstrapLazyResponse';
import { BootstrapRequest, BootstrapRequestActionEnum     } from './BootstrapRequest';
import { BootstrapResponse } from './BootstrapResponse';
import { ChainRequest, ChainRequestActionEnum       } from './ChainRequest';
import { ChainResponse } from './ChainResponse';
import { Confirmation } from './Confirmation';
import { ConfirmationActiveRequest, ConfirmationActiveRequestActionEnum    } from './ConfirmationActiveRequest';
import { ConfirmationActiveResponse } from './ConfirmationActiveResponse';
import { ConfirmationHeightCurrentlyProcessingRequest, ConfirmationHeightCurrentlyProcessingRequestActionEnum   } from './ConfirmationHeightCurrentlyProcessingRequest';
import { ConfirmationHeightCurrentlyProcessingResponse } from './ConfirmationHeightCurrentlyProcessingResponse';
import { ConfirmationHistoryRequest, ConfirmationHistoryRequestActionEnum   } from './ConfirmationHistoryRequest';
import { ConfirmationHistoryResponse } from './ConfirmationHistoryResponse';
import { ConfirmationHistoryResponseConfirmationStats } from './ConfirmationHistoryResponseConfirmationStats';
import { ConfirmationInfo } from './ConfirmationInfo';
import { ConfirmationInfoRequest, ConfirmationInfoRequestActionEnum      } from './ConfirmationInfoRequest';
import { ConfirmationInfoResponse } from './ConfirmationInfoResponse';
import { KeyCreateRequest, KeyCreateRequestActionEnum   } from './KeyCreateRequest';
import { KeyCreateResponse } from './KeyCreateResponse';
import { KeyExpandRequest, KeyExpandRequestActionEnum    } from './KeyExpandRequest';
import { KeyExpandResponse } from './KeyExpandResponse';
import { ModelBoolean } from './ModelBoolean';
import { PendingBlock } from './PendingBlock';
import { PendingRequest, PendingRequestActionEnum        } from './PendingRequest';
import { PendingResponse } from './PendingResponse';
import { ProcessRequest, ProcessRequestActionEnum      } from './ProcessRequest';
import { ProcessResponse } from './ProcessResponse';
import { ReceiveRequest, ReceiveRequestActionEnum      } from './ReceiveRequest';
import { ReceiveResponse } from './ReceiveResponse';
import { SubType } from './SubType';
import { WalletCreateRequest, WalletCreateRequestActionEnum   } from './WalletCreateRequest';
import { WalletCreateResponse } from './WalletCreateResponse';
import { WorkGenerateRequest, WorkGenerateRequestActionEnum     } from './WorkGenerateRequest';
import { WorkGenerateResponse } from './WorkGenerateResponse';

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

const supportedMediaTypes: { [mediaType: string]: number } = {
  "application/json": Infinity,
  "application/octet-stream": 0
}

                 
let enumsMap: Set<string> = new Set<string>([
    "AccountBalanceRequestActionEnum",
    "AccountBlockCountRequestActionEnum",
    "AccountGetRequestActionEnum",
    "AccountHistoryRequestActionEnum",
    "AccountInfoRequestActionEnum",
    "AccountKeyRequestActionEnum",
    "AccountRepresentativeRequestActionEnum",
    "AccountWeightRequestActionEnum",
    "AccountsBalancesRequestActionEnum",
    "AccountsCreateRequestActionEnum",
    "AccountsFrontiersRequestActionEnum",
    "AccountsPendingRequestActionEnum",
    "ActiveDifficultyRequestActionEnum",
    "AvailableSupplyRequestActionEnum",
    "BlockAccountRequestActionEnum",
    "BlockConfirmRequestActionEnum",
    "BlockCountRequestActionEnum",
    "BlockCountTypeRequestActionEnum",
    "BlockCreateRequestActionEnum",
    "BlockCreateRequestTypeEnum",
    "BlockDataJsonTypeEnum",
    "BlockHashRequestActionEnum",
    "BlockInfoRequestActionEnum",
    "BlockState",
    "BlocksInfoRequestActionEnum",
    "BlocksRequestActionEnum",
    "BootstrapAnyRequestActionEnum",
    "BootstrapLazyRequestActionEnum",
    "BootstrapRequestActionEnum",
    "ChainRequestActionEnum",
    "ConfirmationActiveRequestActionEnum",
    "ConfirmationHeightCurrentlyProcessingRequestActionEnum",
    "ConfirmationHistoryRequestActionEnum",
    "ConfirmationInfoRequestActionEnum",
    "KeyCreateRequestActionEnum",
    "KeyExpandRequestActionEnum",
    "ModelBoolean",
    "PendingRequestActionEnum",
    "ProcessRequestActionEnum",
    "ReceiveRequestActionEnum",
    "SubType",
    "WalletCreateRequestActionEnum",
    "WorkGenerateRequestActionEnum",
]);

let typeMap: {[index: string]: any} = {
    "AccountBalanceRequest": AccountBalanceRequest,
    "AccountBalanceResponse": AccountBalanceResponse,
    "AccountBlockCountRequest": AccountBlockCountRequest,
    "AccountBlockCountResponse": AccountBlockCountResponse,
    "AccountGetRequest": AccountGetRequest,
    "AccountGetResponse": AccountGetResponse,
    "AccountHistoryRequest": AccountHistoryRequest,
    "AccountHistoryResponse": AccountHistoryResponse,
    "AccountInfoRequest": AccountInfoRequest,
    "AccountInfoResponse": AccountInfoResponse,
    "AccountKeyRequest": AccountKeyRequest,
    "AccountKeyResponse": AccountKeyResponse,
    "AccountRepresentativeRequest": AccountRepresentativeRequest,
    "AccountRepresentativeResponse": AccountRepresentativeResponse,
    "AccountWeightRequest": AccountWeightRequest,
    "AccountWeightResponse": AccountWeightResponse,
    "AccountsBalancesRequest": AccountsBalancesRequest,
    "AccountsBalancesResponse": AccountsBalancesResponse,
    "AccountsCreateRequest": AccountsCreateRequest,
    "AccountsCreateResponse": AccountsCreateResponse,
    "AccountsFrontiersRequest": AccountsFrontiersRequest,
    "AccountsFrontiersResponse": AccountsFrontiersResponse,
    "AccountsPendingRequest": AccountsPendingRequest,
    "AccountsPendingResponse": AccountsPendingResponse,
    "ActiveDifficultyRequest": ActiveDifficultyRequest,
    "ActiveDifficultyResponse": ActiveDifficultyResponse,
    "AvailableSupplyRequest": AvailableSupplyRequest,
    "AvailableSupplyResponse": AvailableSupplyResponse,
    "Block": Block,
    "BlockAccountRequest": BlockAccountRequest,
    "BlockAccountResponse": BlockAccountResponse,
    "BlockConfirmRequest": BlockConfirmRequest,
    "BlockConfirmResponse": BlockConfirmResponse,
    "BlockCountRequest": BlockCountRequest,
    "BlockCountResponse": BlockCountResponse,
    "BlockCountTypeRequest": BlockCountTypeRequest,
    "BlockCountTypeResponse": BlockCountTypeResponse,
    "BlockCreateRequest": BlockCreateRequest,
    "BlockCreateResponse": BlockCreateResponse,
    "BlockDataJson": BlockDataJson,
    "BlockHashRequest": BlockHashRequest,
    "BlockHashResponse": BlockHashResponse,
    "BlockInfo": BlockInfo,
    "BlockInfoRequest": BlockInfoRequest,
    "BlockInfoResponse": BlockInfoResponse,
    "BlocksInfoRequest": BlocksInfoRequest,
    "BlocksInfoResponse": BlocksInfoResponse,
    "BlocksRequest": BlocksRequest,
    "BlocksResponse": BlocksResponse,
    "BootstrapAnyRequest": BootstrapAnyRequest,
    "BootstrapAnyResponse": BootstrapAnyResponse,
    "BootstrapLazyRequest": BootstrapLazyRequest,
    "BootstrapLazyResponse": BootstrapLazyResponse,
    "BootstrapRequest": BootstrapRequest,
    "BootstrapResponse": BootstrapResponse,
    "ChainRequest": ChainRequest,
    "ChainResponse": ChainResponse,
    "Confirmation": Confirmation,
    "ConfirmationActiveRequest": ConfirmationActiveRequest,
    "ConfirmationActiveResponse": ConfirmationActiveResponse,
    "ConfirmationHeightCurrentlyProcessingRequest": ConfirmationHeightCurrentlyProcessingRequest,
    "ConfirmationHeightCurrentlyProcessingResponse": ConfirmationHeightCurrentlyProcessingResponse,
    "ConfirmationHistoryRequest": ConfirmationHistoryRequest,
    "ConfirmationHistoryResponse": ConfirmationHistoryResponse,
    "ConfirmationHistoryResponseConfirmationStats": ConfirmationHistoryResponseConfirmationStats,
    "ConfirmationInfo": ConfirmationInfo,
    "ConfirmationInfoRequest": ConfirmationInfoRequest,
    "ConfirmationInfoResponse": ConfirmationInfoResponse,
    "KeyCreateRequest": KeyCreateRequest,
    "KeyCreateResponse": KeyCreateResponse,
    "KeyExpandRequest": KeyExpandRequest,
    "KeyExpandResponse": KeyExpandResponse,
    "PendingBlock": PendingBlock,
    "PendingRequest": PendingRequest,
    "PendingResponse": PendingResponse,
    "ProcessRequest": ProcessRequest,
    "ProcessResponse": ProcessResponse,
    "ReceiveRequest": ReceiveRequest,
    "ReceiveResponse": ReceiveResponse,
    "WalletCreateRequest": WalletCreateRequest,
    "WalletCreateResponse": WalletCreateResponse,
    "WorkGenerateRequest": WorkGenerateRequest,
    "WorkGenerateResponse": WorkGenerateResponse,
}

export class ObjectSerializer {
    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap.has(expectedType)) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    var discriminatorType = data[discriminatorProperty];
                    if(typeMap[discriminatorType]){
                        return discriminatorType; // use the type given in the discriminator
                    } else {
                        return expectedType; // discriminator did not map to a type
                    }
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string, format: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType, format));
            }
            return transformedData;
        } else if (type === "Date") {
            if (format == "date") {
                let month = data.getMonth()+1
                month = month < 10 ? "0" + month.toString() : month.toString()
                let day = data.getDate();
                day = day < 10 ? "0" + day.toString() : day.toString();

                return data.getFullYear() + "-" + month + "-" + day;
            } else {
                return data.toISOString();
            }
        } else {
            if (enumsMap.has(type)) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }
            
            // Get the actual type of this object
            type = this.findCorrectType(data, type);

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type, attributeType.format);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string, format: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType, format));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap.has(type)) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type, attributeType.format);
            }
            return instance;
        }
    }


    /**
     * Normalize media type
     *
     * We currently do not handle any media types attributes, i.e. anything
     * after a semicolon. All content is assumed to be UTF-8 compatible.
     */
    public static normalizeMediaType(mediaType: string | undefined): string | undefined {
        if (mediaType === undefined) {
            return undefined;
        }
        return mediaType.split(";")[0].trim().toLowerCase();
    }

    /**
     * From a list of possible media types, choose the one we can handle best.
     *
     * The order of the given media types does not have any impact on the choice
     * made.
     */
    public static getPreferredMediaType(mediaTypes: Array<string>): string {
        /** According to OAS 3 we should default to json */
        if (!mediaTypes) {
            return "application/json";
        }

        const normalMediaTypes = mediaTypes.map(this.normalizeMediaType);
        let selectedMediaType: string | undefined = undefined;
        let selectedRank: number = -Infinity;
        for (const mediaType of normalMediaTypes) {
            if (supportedMediaTypes[mediaType!] > selectedRank) {
                selectedMediaType = mediaType;
                selectedRank = supportedMediaTypes[mediaType!];
            }
        }

        if (selectedMediaType === undefined) {
            throw new Error("None of the given media types are supported: " + mediaTypes.join(", "));
        }

        return selectedMediaType!;
    }

    /**
     * Convert data to a string according the given media type
     */
    public static stringify(data: any, mediaType: string): string {
        if (mediaType === "application/json") {
            return JSON.stringify(data);
        }

        throw new Error("The mediaType " + mediaType + " is not supported by ObjectSerializer.stringify.");
    }

    /**
     * Parse data from a string according to the given media type
     */
    public static parse(rawData: string, mediaType: string | undefined) {
        if (mediaType === undefined) {
            throw new Error("Cannot parse content. No Content-Type defined.");
        }

        if (mediaType === "application/json") {
            return JSON.parse(rawData);
        }

        throw new Error("The mediaType " + mediaType + " is not supported by ObjectSerializer.parse.");
    }
}
