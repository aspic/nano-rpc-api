/* tslint:disable */
/* eslint-disable */
/**
 * nano-rpc-api
 * API specification for the [Nano Node RPC API](https://docs.nano.org/commands/rpc-protocol) 
 *
 * The version of the OpenAPI document: 19.0.0-alpha
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    AccountBalanceRequest,
    AccountBalanceRequestFromJSON,
    AccountBalanceRequestToJSON,
    AccountBalanceResponse,
    AccountBalanceResponseFromJSON,
    AccountBalanceResponseToJSON,
    AccountBlockCountRequest,
    AccountBlockCountRequestFromJSON,
    AccountBlockCountRequestToJSON,
    AccountBlockCountResponse,
    AccountBlockCountResponseFromJSON,
    AccountBlockCountResponseToJSON,
    AccountGetRequest,
    AccountGetRequestFromJSON,
    AccountGetRequestToJSON,
    AccountGetResponse,
    AccountGetResponseFromJSON,
    AccountGetResponseToJSON,
    AccountHistoryRequest,
    AccountHistoryRequestFromJSON,
    AccountHistoryRequestToJSON,
    AccountHistoryResponse,
    AccountHistoryResponseFromJSON,
    AccountHistoryResponseToJSON,
    AccountInfoRequest,
    AccountInfoRequestFromJSON,
    AccountInfoRequestToJSON,
    AccountInfoResponse,
    AccountInfoResponseFromJSON,
    AccountInfoResponseToJSON,
    AccountKeyRequest,
    AccountKeyRequestFromJSON,
    AccountKeyRequestToJSON,
    AccountKeyResponse,
    AccountKeyResponseFromJSON,
    AccountKeyResponseToJSON,
    AccountRepresentativeRequest,
    AccountRepresentativeRequestFromJSON,
    AccountRepresentativeRequestToJSON,
    AccountRepresentativeResponse,
    AccountRepresentativeResponseFromJSON,
    AccountRepresentativeResponseToJSON,
    AccountWeightRequest,
    AccountWeightRequestFromJSON,
    AccountWeightRequestToJSON,
    AccountWeightResponse,
    AccountWeightResponseFromJSON,
    AccountWeightResponseToJSON,
    AccountsBalancesRequest,
    AccountsBalancesRequestFromJSON,
    AccountsBalancesRequestToJSON,
    AccountsBalancesResponse,
    AccountsBalancesResponseFromJSON,
    AccountsBalancesResponseToJSON,
    AccountsFrontiersRequest,
    AccountsFrontiersRequestFromJSON,
    AccountsFrontiersRequestToJSON,
    AccountsFrontiersResponse,
    AccountsFrontiersResponseFromJSON,
    AccountsFrontiersResponseToJSON,
    AccountsPendingRequest,
    AccountsPendingRequestFromJSON,
    AccountsPendingRequestToJSON,
    AccountsPendingResponse,
    AccountsPendingResponseFromJSON,
    AccountsPendingResponseToJSON,
    ActiveDifficultyRequest,
    ActiveDifficultyRequestFromJSON,
    ActiveDifficultyRequestToJSON,
    ActiveDifficultyResponse,
    ActiveDifficultyResponseFromJSON,
    ActiveDifficultyResponseToJSON,
    AvailableSupplyRequest,
    AvailableSupplyRequestFromJSON,
    AvailableSupplyRequestToJSON,
    AvailableSupplyResponse,
    AvailableSupplyResponseFromJSON,
    AvailableSupplyResponseToJSON,
    BlockAccountRequest,
    BlockAccountRequestFromJSON,
    BlockAccountRequestToJSON,
    BlockAccountResponse,
    BlockAccountResponseFromJSON,
    BlockAccountResponseToJSON,
    BlockConfirmRequest,
    BlockConfirmRequestFromJSON,
    BlockConfirmRequestToJSON,
    BlockConfirmResponse,
    BlockConfirmResponseFromJSON,
    BlockConfirmResponseToJSON,
    BlockCountRequest,
    BlockCountRequestFromJSON,
    BlockCountRequestToJSON,
    BlockCountResponse,
    BlockCountResponseFromJSON,
    BlockCountResponseToJSON,
    BlockCountTypeRequest,
    BlockCountTypeRequestFromJSON,
    BlockCountTypeRequestToJSON,
    BlockCountTypeResponse,
    BlockCountTypeResponseFromJSON,
    BlockCountTypeResponseToJSON,
    BlockCreateRequest,
    BlockCreateRequestFromJSON,
    BlockCreateRequestToJSON,
    BlockCreateResponse,
    BlockCreateResponseFromJSON,
    BlockCreateResponseToJSON,
    BlockHashRequest,
    BlockHashRequestFromJSON,
    BlockHashRequestToJSON,
    BlockHashResponse,
    BlockHashResponseFromJSON,
    BlockHashResponseToJSON,
    BlockInfoRequest,
    BlockInfoRequestFromJSON,
    BlockInfoRequestToJSON,
    BlockInfoResponse,
    BlockInfoResponseFromJSON,
    BlockInfoResponseToJSON,
    BlocksInfoRequest,
    BlocksInfoRequestFromJSON,
    BlocksInfoRequestToJSON,
    BlocksInfoResponse,
    BlocksInfoResponseFromJSON,
    BlocksInfoResponseToJSON,
    BlocksRequest,
    BlocksRequestFromJSON,
    BlocksRequestToJSON,
    BlocksResponse,
    BlocksResponseFromJSON,
    BlocksResponseToJSON,
    BootstrapAnyRequest,
    BootstrapAnyRequestFromJSON,
    BootstrapAnyRequestToJSON,
    BootstrapAnyResponse,
    BootstrapAnyResponseFromJSON,
    BootstrapAnyResponseToJSON,
    BootstrapLazyRequest,
    BootstrapLazyRequestFromJSON,
    BootstrapLazyRequestToJSON,
    BootstrapLazyResponse,
    BootstrapLazyResponseFromJSON,
    BootstrapLazyResponseToJSON,
    BootstrapRequest,
    BootstrapRequestFromJSON,
    BootstrapRequestToJSON,
    BootstrapResponse,
    BootstrapResponseFromJSON,
    BootstrapResponseToJSON,
    ChainRequest,
    ChainRequestFromJSON,
    ChainRequestToJSON,
    ChainResponse,
    ChainResponseFromJSON,
    ChainResponseToJSON,
    ConfirmationActiveRequest,
    ConfirmationActiveRequestFromJSON,
    ConfirmationActiveRequestToJSON,
    ConfirmationActiveResponse,
    ConfirmationActiveResponseFromJSON,
    ConfirmationActiveResponseToJSON,
    ConfirmationHistoryRequest,
    ConfirmationHistoryRequestFromJSON,
    ConfirmationHistoryRequestToJSON,
    ConfirmationHistoryResponse,
    ConfirmationHistoryResponseFromJSON,
    ConfirmationHistoryResponseToJSON,
    ConfirmationInfoRequest,
    ConfirmationInfoRequestFromJSON,
    ConfirmationInfoRequestToJSON,
    ConfirmationInfoResponse,
    ConfirmationInfoResponseFromJSON,
    ConfirmationInfoResponseToJSON,
    KeyCreateRequest,
    KeyCreateRequestFromJSON,
    KeyCreateRequestToJSON,
    KeyCreateResponse,
    KeyCreateResponseFromJSON,
    KeyCreateResponseToJSON,
    KeyExpandRequest,
    KeyExpandRequestFromJSON,
    KeyExpandRequestToJSON,
    KeyExpandResponse,
    KeyExpandResponseFromJSON,
    KeyExpandResponseToJSON,
    ProcessRequest,
    ProcessRequestFromJSON,
    ProcessRequestToJSON,
    ProcessResponse,
    ProcessResponseFromJSON,
    ProcessResponseToJSON,
    WorkGenerateRequest,
    WorkGenerateRequestFromJSON,
    WorkGenerateRequestToJSON,
    WorkGenerateResponse,
    WorkGenerateResponseFromJSON,
    WorkGenerateResponseToJSON,
} from '../models';

export interface AccountBalanceOperationRequest {
    accountBalanceRequest?: AccountBalanceRequest;
}

export interface AccountBlockCountOperationRequest {
    accountBlockCountRequest?: AccountBlockCountRequest;
}

export interface AccountGetOperationRequest {
    accountGetRequest?: AccountGetRequest;
}

export interface AccountHistoryOperationRequest {
    accountHistoryRequest?: AccountHistoryRequest;
}

export interface AccountInfoOperationRequest {
    accountInfoRequest?: AccountInfoRequest;
}

export interface AccountKeyOperationRequest {
    accountKeyRequest?: AccountKeyRequest;
}

export interface AccountRepresentativeOperationRequest {
    accountRepresentativeRequest?: AccountRepresentativeRequest;
}

export interface AccountWeightOperationRequest {
    accountWeightRequest?: AccountWeightRequest;
}

export interface AccountsBalancesOperationRequest {
    accountsBalancesRequest?: AccountsBalancesRequest;
}

export interface AccountsFrontiersOperationRequest {
    accountsFrontiersRequest?: AccountsFrontiersRequest;
}

export interface AccountsPendingOperationRequest {
    accountsPendingRequest?: AccountsPendingRequest;
}

export interface ActiveDifficultyOperationRequest {
    activeDifficultyRequest?: ActiveDifficultyRequest;
}

export interface AvailableSupplyOperationRequest {
    availableSupplyRequest?: AvailableSupplyRequest;
}

export interface BlockAccountOperationRequest {
    blockAccountRequest?: BlockAccountRequest;
}

export interface BlockConfirmOperationRequest {
    blockConfirmRequest?: BlockConfirmRequest;
}

export interface BlockCountOperationRequest {
    blockCountRequest?: BlockCountRequest;
}

export interface BlockCountTypeOperationRequest {
    blockCountTypeRequest?: BlockCountTypeRequest;
}

export interface BlockCreateOperationRequest {
    blockCreateRequest?: BlockCreateRequest;
}

export interface BlockHashOperationRequest {
    blockHashRequest?: BlockHashRequest;
}

export interface BlockInfoOperationRequest {
    blockInfoRequest?: BlockInfoRequest;
}

export interface BlocksOperationRequest {
    blocksRequest?: BlocksRequest;
}

export interface BlocksInfoOperationRequest {
    blocksInfoRequest?: BlocksInfoRequest;
}

export interface BootstrapOperationRequest {
    bootstrapRequest?: BootstrapRequest;
}

export interface BootstrapAnyOperationRequest {
    bootstrapAnyRequest?: BootstrapAnyRequest;
}

export interface BootstrapLazyOperationRequest {
    bootstrapLazyRequest?: BootstrapLazyRequest;
}

export interface ChainOperationRequest {
    chainRequest?: ChainRequest;
}

export interface ConfirmationActiveOperationRequest {
    confirmationActiveRequest?: ConfirmationActiveRequest;
}

export interface ConfirmationHistoryOperationRequest {
    confirmationHistoryRequest?: ConfirmationHistoryRequest;
}

export interface ConfirmationInfoOperationRequest {
    confirmationInfoRequest?: ConfirmationInfoRequest;
}

export interface KeyCreateOperationRequest {
    keyCreateRequest?: KeyCreateRequest;
}

export interface KeyExpandOperationRequest {
    keyExpandRequest?: KeyExpandRequest;
}

export interface ProcessOperationRequest {
    processRequest?: ProcessRequest;
}

export interface WorkGenerateOperationRequest {
    workGenerateRequest?: WorkGenerateRequest;
}

/**
 * 
 */
export class NodeRPCsApi extends runtime.BaseAPI {

    /**
     * Returns how many RAW is owned and how many have not yet been received by **account** > This call may return results that include unconfirmed blocks, so it should not be used in any processes or integrations requiring only details from blocks confirmed by the network. 
     */
    async accountBalanceRaw(requestParameters: AccountBalanceOperationRequest): Promise<runtime.ApiResponse<AccountBalanceResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/#account_balance`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AccountBalanceRequestToJSON(requestParameters.accountBalanceRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountBalanceResponseFromJSON(jsonValue));
    }

    /**
     * Returns how many RAW is owned and how many have not yet been received by **account** > This call may return results that include unconfirmed blocks, so it should not be used in any processes or integrations requiring only details from blocks confirmed by the network. 
     */
    async accountBalance(requestParameters: AccountBalanceOperationRequest): Promise<AccountBalanceResponse> {
        const response = await this.accountBalanceRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get number of blocks for a specific account
     */
    async accountBlockCountRaw(requestParameters: AccountBlockCountOperationRequest): Promise<runtime.ApiResponse<AccountBlockCountResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/#account_block_count`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AccountBlockCountRequestToJSON(requestParameters.accountBlockCountRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountBlockCountResponseFromJSON(jsonValue));
    }

    /**
     * Get number of blocks for a specific account
     */
    async accountBlockCount(requestParameters: AccountBlockCountOperationRequest): Promise<AccountBlockCountResponse> {
        const response = await this.accountBlockCountRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get account for the public key
     */
    async accountGetRaw(requestParameters: AccountGetOperationRequest): Promise<runtime.ApiResponse<AccountGetResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/#account_get`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AccountGetRequestToJSON(requestParameters.accountGetRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountGetResponseFromJSON(jsonValue));
    }

    /**
     * Get account for the public key
     */
    async accountGet(requestParameters: AccountGetOperationRequest): Promise<AccountGetResponse> {
        const response = await this.accountGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Gets the account history. Reports send/receive information for an account. 
     */
    async accountHistoryRaw(requestParameters: AccountHistoryOperationRequest): Promise<runtime.ApiResponse<AccountHistoryResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/#account_history`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AccountHistoryRequestToJSON(requestParameters.accountHistoryRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountHistoryResponseFromJSON(jsonValue));
    }

    /**
     * Gets the account history. Reports send/receive information for an account. 
     */
    async accountHistory(requestParameters: AccountHistoryOperationRequest): Promise<AccountHistoryResponse> {
        const response = await this.accountHistoryRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns frontier, open block, change representative block, balance, last modified timestamp from local database & block count for **account**. Only works for accounts that have an entry on the ledger, will return _Account not found_ otherwise. 
     */
    async accountInfoRaw(requestParameters: AccountInfoOperationRequest): Promise<runtime.ApiResponse<AccountInfoResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/#account_info`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AccountInfoRequestToJSON(requestParameters.accountInfoRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountInfoResponseFromJSON(jsonValue));
    }

    /**
     * Returns frontier, open block, change representative block, balance, last modified timestamp from local database & block count for **account**. Only works for accounts that have an entry on the ledger, will return _Account not found_ otherwise. 
     */
    async accountInfo(requestParameters: AccountInfoOperationRequest): Promise<AccountInfoResponse> {
        const response = await this.accountInfoRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get the public key for **account** 
     */
    async accountKeyRaw(requestParameters: AccountKeyOperationRequest): Promise<runtime.ApiResponse<AccountKeyResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/#account_key`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AccountKeyRequestToJSON(requestParameters.accountKeyRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountKeyResponseFromJSON(jsonValue));
    }

    /**
     * Get the public key for **account** 
     */
    async accountKey(requestParameters: AccountKeyOperationRequest): Promise<AccountKeyResponse> {
        const response = await this.accountKeyRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns the representative for **account** 
     */
    async accountRepresentativeRaw(requestParameters: AccountRepresentativeOperationRequest): Promise<runtime.ApiResponse<AccountRepresentativeResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/#account_representative`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AccountRepresentativeRequestToJSON(requestParameters.accountRepresentativeRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountRepresentativeResponseFromJSON(jsonValue));
    }

    /**
     * Returns the representative for **account** 
     */
    async accountRepresentative(requestParameters: AccountRepresentativeOperationRequest): Promise<AccountRepresentativeResponse> {
        const response = await this.accountRepresentativeRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns the voting weight for **account** 
     */
    async accountWeightRaw(requestParameters: AccountWeightOperationRequest): Promise<runtime.ApiResponse<AccountWeightResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/#account_weight`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AccountWeightRequestToJSON(requestParameters.accountWeightRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountWeightResponseFromJSON(jsonValue));
    }

    /**
     * Returns the voting weight for **account** 
     */
    async accountWeight(requestParameters: AccountWeightOperationRequest): Promise<AccountWeightResponse> {
        const response = await this.accountWeightRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns how many RAW is owned and how many have not yet been received by **accounts list**  This call may return results that include unconfirmed blocks, so it should not be used in any processes or integrations requiring only details from blocks confirmed by the network. 
     */
    async accountsBalancesRaw(requestParameters: AccountsBalancesOperationRequest): Promise<runtime.ApiResponse<AccountsBalancesResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/#accounts_balances`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AccountsBalancesRequestToJSON(requestParameters.accountsBalancesRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountsBalancesResponseFromJSON(jsonValue));
    }

    /**
     * Returns how many RAW is owned and how many have not yet been received by **accounts list**  This call may return results that include unconfirmed blocks, so it should not be used in any processes or integrations requiring only details from blocks confirmed by the network. 
     */
    async accountsBalances(requestParameters: AccountsBalancesOperationRequest): Promise<AccountsBalancesResponse> {
        const response = await this.accountsBalancesRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns a list of pairs of account and block hash representing the head block for **accounts list**  This call may return results that include unconfirmed blocks, so it should not be used in any processes or integrations requiring only details from blocks confirmed by the network. 
     */
    async accountsFrontiersRaw(requestParameters: AccountsFrontiersOperationRequest): Promise<runtime.ApiResponse<AccountsFrontiersResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/#accounts_frontiers`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AccountsFrontiersRequestToJSON(requestParameters.accountsFrontiersRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountsFrontiersResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of pairs of account and block hash representing the head block for **accounts list**  This call may return results that include unconfirmed blocks, so it should not be used in any processes or integrations requiring only details from blocks confirmed by the network. 
     */
    async accountsFrontiers(requestParameters: AccountsFrontiersOperationRequest): Promise<AccountsFrontiersResponse> {
        const response = await this.accountsFrontiersRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns a list of block hashes which have not yet been received by these accounts
     */
    async accountsPendingRaw(requestParameters: AccountsPendingOperationRequest): Promise<runtime.ApiResponse<AccountsPendingResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/#accounts_pending`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AccountsPendingRequestToJSON(requestParameters.accountsPendingRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountsPendingResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of block hashes which have not yet been received by these accounts
     */
    async accountsPending(requestParameters: AccountsPendingOperationRequest): Promise<AccountsPendingResponse> {
        const response = await this.accountsPendingRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns the difficulty values (16 hexadecimal digits string, 64 bit) for the minimum required on the network (network_minimum) as well as the current active difficulty seen on the network (network_current, 5 minute trended average of adjusted difficulty seen on confirmed transactions) which can be used to perform rework for better prioritization of transaction processing. A multiplier of the network_current from the base difficulty of network_minimum is also provided for comparison. 
     */
    async activeDifficultyRaw(requestParameters: ActiveDifficultyOperationRequest): Promise<runtime.ApiResponse<ActiveDifficultyResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/#active_difficulty`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ActiveDifficultyRequestToJSON(requestParameters.activeDifficultyRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ActiveDifficultyResponseFromJSON(jsonValue));
    }

    /**
     * Returns the difficulty values (16 hexadecimal digits string, 64 bit) for the minimum required on the network (network_minimum) as well as the current active difficulty seen on the network (network_current, 5 minute trended average of adjusted difficulty seen on confirmed transactions) which can be used to perform rework for better prioritization of transaction processing. A multiplier of the network_current from the base difficulty of network_minimum is also provided for comparison. 
     */
    async activeDifficulty(requestParameters: ActiveDifficultyOperationRequest): Promise<ActiveDifficultyResponse> {
        const response = await this.activeDifficultyRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns how many raw are in the public supply 
     */
    async availableSupplyRaw(requestParameters: AvailableSupplyOperationRequest): Promise<runtime.ApiResponse<AvailableSupplyResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/#available_supply`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AvailableSupplyRequestToJSON(requestParameters.availableSupplyRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AvailableSupplyResponseFromJSON(jsonValue));
    }

    /**
     * Returns how many raw are in the public supply 
     */
    async availableSupply(requestParameters: AvailableSupplyOperationRequest): Promise<AvailableSupplyResponse> {
        const response = await this.availableSupplyRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns the account containing block 
     */
    async blockAccountRaw(requestParameters: BlockAccountOperationRequest): Promise<runtime.ApiResponse<BlockAccountResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/#block_account`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BlockAccountRequestToJSON(requestParameters.blockAccountRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockAccountResponseFromJSON(jsonValue));
    }

    /**
     * Returns the account containing block 
     */
    async blockAccount(requestParameters: BlockAccountOperationRequest): Promise<BlockAccountResponse> {
        const response = await this.blockAccountRaw(requestParameters);
        return await response.value();
    }

    /**
     * Request confirmation for **block** from known online representative nodes. Check results with confirmation history. 
     */
    async blockConfirmRaw(requestParameters: BlockConfirmOperationRequest): Promise<runtime.ApiResponse<BlockConfirmResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/#block_confirm`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BlockConfirmRequestToJSON(requestParameters.blockConfirmRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockConfirmResponseFromJSON(jsonValue));
    }

    /**
     * Request confirmation for **block** from known online representative nodes. Check results with confirmation history. 
     */
    async blockConfirm(requestParameters: BlockConfirmOperationRequest): Promise<BlockConfirmResponse> {
        const response = await this.blockConfirmRaw(requestParameters);
        return await response.value();
    }

    /**
     * Reports the number of blocks in the ledger and unchecked synchronizing blocks. 
     */
    async blockCountRaw(requestParameters: BlockCountOperationRequest): Promise<runtime.ApiResponse<BlockCountResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/#block_count`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BlockCountRequestToJSON(requestParameters.blockCountRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockCountResponseFromJSON(jsonValue));
    }

    /**
     * Reports the number of blocks in the ledger and unchecked synchronizing blocks. 
     */
    async blockCount(requestParameters: BlockCountOperationRequest): Promise<BlockCountResponse> {
        const response = await this.blockCountRaw(requestParameters);
        return await response.value();
    }

    /**
     * Reports the number of blocks in the ledger by type (send, receive, open, change, state with version) 
     */
    async blockCountTypeRaw(requestParameters: BlockCountTypeOperationRequest): Promise<runtime.ApiResponse<BlockCountTypeResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/#block_count_type`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BlockCountTypeRequestToJSON(requestParameters.blockCountTypeRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockCountTypeResponseFromJSON(jsonValue));
    }

    /**
     * Reports the number of blocks in the ledger by type (send, receive, open, change, state with version) 
     */
    async blockCountType(requestParameters: BlockCountTypeOperationRequest): Promise<BlockCountTypeResponse> {
        const response = await this.blockCountTypeRaw(requestParameters);
        return await response.value();
    }

    /**
     * Creates a json representations of new block based on input data & signed with **private key** or **account** in **wallet**. Use for offline signing. 
     */
    async blockCreateRaw(requestParameters: BlockCreateOperationRequest): Promise<runtime.ApiResponse<BlockCreateResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/#block_create`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BlockCreateRequestToJSON(requestParameters.blockCreateRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockCreateResponseFromJSON(jsonValue));
    }

    /**
     * Creates a json representations of new block based on input data & signed with **private key** or **account** in **wallet**. Use for offline signing. 
     */
    async blockCreate(requestParameters: BlockCreateOperationRequest): Promise<BlockCreateResponse> {
        const response = await this.blockCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returning block hash for given block content. Using the optional **json_block** is recommended since v19.0. 
     */
    async blockHashRaw(requestParameters: BlockHashOperationRequest): Promise<runtime.ApiResponse<BlockHashResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/#block_hash`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BlockHashRequestToJSON(requestParameters.blockHashRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockHashResponseFromJSON(jsonValue));
    }

    /**
     * Returning block hash for given block content. Using the optional **json_block** is recommended since v19.0. 
     */
    async blockHash(requestParameters: BlockHashOperationRequest): Promise<BlockHashResponse> {
        const response = await this.blockHashRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieves a json representation of the block in `contents` along with:  * _since version 18.0_: `block_account`, transaction `amount`, block `balance`, block `height` in account chain, block local modification `timestamp` * _since version 19.0_: Whether block was `confirmed`, `subtype` (for state blocks) of `send`, `receive`,  `change` or `epoch`  Using the optional `json_block` is recommended since v19.0. 
     */
    async blockInfoRaw(requestParameters: BlockInfoOperationRequest): Promise<runtime.ApiResponse<BlockInfoResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/#block_info`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BlockInfoRequestToJSON(requestParameters.blockInfoRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockInfoResponseFromJSON(jsonValue));
    }

    /**
     * Retrieves a json representation of the block in `contents` along with:  * _since version 18.0_: `block_account`, transaction `amount`, block `balance`, block `height` in account chain, block local modification `timestamp` * _since version 19.0_: Whether block was `confirmed`, `subtype` (for state blocks) of `send`, `receive`,  `change` or `epoch`  Using the optional `json_block` is recommended since v19.0. 
     */
    async blockInfo(requestParameters: BlockInfoOperationRequest): Promise<BlockInfoResponse> {
        const response = await this.blockInfoRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieves a json representations of **blocks**. 
     */
    async blocksRaw(requestParameters: BlocksOperationRequest): Promise<runtime.ApiResponse<BlocksResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/#blocks`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BlocksRequestToJSON(requestParameters.blocksRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => BlocksResponseFromJSON(jsonValue));
    }

    /**
     * Retrieves a json representations of **blocks**. 
     */
    async blocks(requestParameters: BlocksOperationRequest): Promise<BlocksResponse> {
        const response = await this.blocksRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieves a json representations of blocks in contents along with:  * _since version 18.0_: `block_account`, transaction `amount`, block `balance`, block `height` in account chain, block local modification  timestamp * _since version 19.0_: Whether block was `confirmed`, `subtype` (for state blocks) of `send`, `receive`, `change` or `epoch` 
     */
    async blocksInfoRaw(requestParameters: BlocksInfoOperationRequest): Promise<runtime.ApiResponse<BlocksInfoResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/#blocks_info`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BlocksInfoRequestToJSON(requestParameters.blocksInfoRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => BlocksInfoResponseFromJSON(jsonValue));
    }

    /**
     * Retrieves a json representations of blocks in contents along with:  * _since version 18.0_: `block_account`, transaction `amount`, block `balance`, block `height` in account chain, block local modification  timestamp * _since version 19.0_: Whether block was `confirmed`, `subtype` (for state blocks) of `send`, `receive`, `change` or `epoch` 
     */
    async blocksInfo(requestParameters: BlocksInfoOperationRequest): Promise<BlocksInfoResponse> {
        const response = await this.blocksInfoRaw(requestParameters);
        return await response.value();
    }

    /**
     * Initialize bootstrap to specific **IP address** and **port**. Not compatible with launch flag [--disable_legacy_bootstrap](https://docs.nano.org/commands/command-line-interface/#-disable_legacy_bootstrap) 
     */
    async bootstrapRaw(requestParameters: BootstrapOperationRequest): Promise<runtime.ApiResponse<BootstrapResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/#bootstrap`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BootstrapRequestToJSON(requestParameters.bootstrapRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => BootstrapResponseFromJSON(jsonValue));
    }

    /**
     * Initialize bootstrap to specific **IP address** and **port**. Not compatible with launch flag [--disable_legacy_bootstrap](https://docs.nano.org/commands/command-line-interface/#-disable_legacy_bootstrap) 
     */
    async bootstrap(requestParameters: BootstrapOperationRequest): Promise<BootstrapResponse> {
        const response = await this.bootstrapRaw(requestParameters);
        return await response.value();
    }

    /**
     * Initialize multi-connection bootstrap to random peers. Not compatible with launch flag [--disable_legacy_bootstrap](https://docs.nano.org/commands/command-line-interface/#-disable_legacy_bootstrap) 
     */
    async bootstrapAnyRaw(requestParameters: BootstrapAnyOperationRequest): Promise<runtime.ApiResponse<BootstrapAnyResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/#bootstrap_any`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BootstrapAnyRequestToJSON(requestParameters.bootstrapAnyRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => BootstrapAnyResponseFromJSON(jsonValue));
    }

    /**
     * Initialize multi-connection bootstrap to random peers. Not compatible with launch flag [--disable_legacy_bootstrap](https://docs.nano.org/commands/command-line-interface/#-disable_legacy_bootstrap) 
     */
    async bootstrapAny(requestParameters: BootstrapAnyOperationRequest): Promise<BootstrapAnyResponse> {
        const response = await this.bootstrapAnyRaw(requestParameters);
        return await response.value();
    }

    /**
     * _version 17.0+_  Initialize lazy bootstrap with given block hash. Not compatible with launch flag [--disable_lazy_bootstrap](https://docs.nano.org/commands/command-line-interface/#-disable_lazy_bootstrap) 
     */
    async bootstrapLazyRaw(requestParameters: BootstrapLazyOperationRequest): Promise<runtime.ApiResponse<BootstrapLazyResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/#bootstrap_lazy`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BootstrapLazyRequestToJSON(requestParameters.bootstrapLazyRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => BootstrapLazyResponseFromJSON(jsonValue));
    }

    /**
     * _version 17.0+_  Initialize lazy bootstrap with given block hash. Not compatible with launch flag [--disable_lazy_bootstrap](https://docs.nano.org/commands/command-line-interface/#-disable_lazy_bootstrap) 
     */
    async bootstrapLazy(requestParameters: BootstrapLazyOperationRequest): Promise<BootstrapLazyResponse> {
        const response = await this.bootstrapLazyRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns a consecutive list of block hashes in the account chain starting at **block** back to **count** (direction from frontier back to open block, from newer blocks to older). Will list all blocks back to the open block of this chain when count is set to \"-1\". The requested block hash is included in the answer. 
     */
    async chainRaw(requestParameters: ChainOperationRequest): Promise<runtime.ApiResponse<ChainResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/#chain`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ChainRequestToJSON(requestParameters.chainRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ChainResponseFromJSON(jsonValue));
    }

    /**
     * Returns a consecutive list of block hashes in the account chain starting at **block** back to **count** (direction from frontier back to open block, from newer blocks to older). Will list all blocks back to the open block of this chain when count is set to \"-1\". The requested block hash is included in the answer. 
     */
    async chain(requestParameters: ChainOperationRequest): Promise<ChainResponse> {
        const response = await this.chainRaw(requestParameters);
        return await response.value();
    }

    /**
     * _version 16.0+_  Returns list of active elections roots (excluding stopped & aborted elections). Find info about specific root with confirmation_info  The roots provided are two parts and differ between the first account block and subsequent blocks:  * First account block (open): 0000000000000000000000000000000000000000000000000000000000000000 + account public key * Other blocks: previous hash + previous hash 
     */
    async confirmationActiveRaw(requestParameters: ConfirmationActiveOperationRequest): Promise<runtime.ApiResponse<ConfirmationActiveResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/#confirmation_active`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ConfirmationActiveRequestToJSON(requestParameters.confirmationActiveRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ConfirmationActiveResponseFromJSON(jsonValue));
    }

    /**
     * _version 16.0+_  Returns list of active elections roots (excluding stopped & aborted elections). Find info about specific root with confirmation_info  The roots provided are two parts and differ between the first account block and subsequent blocks:  * First account block (open): 0000000000000000000000000000000000000000000000000000000000000000 + account public key * Other blocks: previous hash + previous hash 
     */
    async confirmationActive(requestParameters: ConfirmationActiveOperationRequest): Promise<ConfirmationActiveResponse> {
        const response = await this.confirmationActiveRaw(requestParameters);
        return await response.value();
    }

    /**
     * _version 12.0+_ _duration, time, confirmation_stats: version 17.0+_  Returns hash, tally weight, election duration (in milliseconds), election confirmation timestamp for recent elections winners. Also returns stats: count of elections in history (limited to 2048) & average duration time  With version 19.0+ `confirmation_history_size` can be managed in [config.json](https://docs.nano.org/running-a-node/configuration/#example-file) to adjust the number of elections to be kept in history and returned by this call. Due to timings inside the node, the default 2048 limit will return all confirmations up to traffic levels of  approximately 56 confirmations/sec. To properly track levels above this, increase this value or use the confirmation subscription through the [websocket](https://docs.nano.org/integration-guides/advanced/#websocket-support) instead. 
     */
    async confirmationHistoryRaw(requestParameters: ConfirmationHistoryOperationRequest): Promise<runtime.ApiResponse<ConfirmationHistoryResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/#confirmation_history`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ConfirmationHistoryRequestToJSON(requestParameters.confirmationHistoryRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ConfirmationHistoryResponseFromJSON(jsonValue));
    }

    /**
     * _version 12.0+_ _duration, time, confirmation_stats: version 17.0+_  Returns hash, tally weight, election duration (in milliseconds), election confirmation timestamp for recent elections winners. Also returns stats: count of elections in history (limited to 2048) & average duration time  With version 19.0+ `confirmation_history_size` can be managed in [config.json](https://docs.nano.org/running-a-node/configuration/#example-file) to adjust the number of elections to be kept in history and returned by this call. Due to timings inside the node, the default 2048 limit will return all confirmations up to traffic levels of  approximately 56 confirmations/sec. To properly track levels above this, increase this value or use the confirmation subscription through the [websocket](https://docs.nano.org/integration-guides/advanced/#websocket-support) instead. 
     */
    async confirmationHistory(requestParameters: ConfirmationHistoryOperationRequest): Promise<ConfirmationHistoryResponse> {
        const response = await this.confirmationHistoryRaw(requestParameters);
        return await response.value();
    }

    /**
     * _version 16.0+_  Returns info about active election by *root*. Including announcements count, last winner (initially local ledger block), total tally of voted representatives, concurrent blocks with tally & block contents for each. Using the optional `json_block` is recommended since v19.0.  The roots provided are two parts and differ between the first account block and subsequent blocks:  * First account block (open): 0000000000000000000000000000000000000000000000000000000000000000 + account public key * Other blocks: previous hash + previous hash 
     */
    async confirmationInfoRaw(requestParameters: ConfirmationInfoOperationRequest): Promise<runtime.ApiResponse<ConfirmationInfoResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/#confirmation_info`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ConfirmationInfoRequestToJSON(requestParameters.confirmationInfoRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ConfirmationInfoResponseFromJSON(jsonValue));
    }

    /**
     * _version 16.0+_  Returns info about active election by *root*. Including announcements count, last winner (initially local ledger block), total tally of voted representatives, concurrent blocks with tally & block contents for each. Using the optional `json_block` is recommended since v19.0.  The roots provided are two parts and differ between the first account block and subsequent blocks:  * First account block (open): 0000000000000000000000000000000000000000000000000000000000000000 + account public key * Other blocks: previous hash + previous hash 
     */
    async confirmationInfo(requestParameters: ConfirmationInfoOperationRequest): Promise<ConfirmationInfoResponse> {
        const response = await this.confirmationInfoRaw(requestParameters);
        return await response.value();
    }

    /**
     * Generates an **adhoc random** keypair 
     */
    async keyCreateRaw(requestParameters: KeyCreateOperationRequest): Promise<runtime.ApiResponse<KeyCreateResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/#key_create`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: KeyCreateRequestToJSON(requestParameters.keyCreateRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => KeyCreateResponseFromJSON(jsonValue));
    }

    /**
     * Generates an **adhoc random** keypair 
     */
    async keyCreate(requestParameters: KeyCreateOperationRequest): Promise<KeyCreateResponse> {
        const response = await this.keyCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Derive public key and account number from **private key** 
     */
    async keyExpandRaw(requestParameters: KeyExpandOperationRequest): Promise<runtime.ApiResponse<KeyExpandResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/#key_expand`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: KeyExpandRequestToJSON(requestParameters.keyExpandRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => KeyExpandResponseFromJSON(jsonValue));
    }

    /**
     * Derive public key and account number from **private key** 
     */
    async keyExpand(requestParameters: KeyExpandOperationRequest): Promise<KeyExpandResponse> {
        const response = await this.keyExpandRaw(requestParameters);
        return await response.value();
    }

    /**
     * Publish block to the network
     */
    async processRaw(requestParameters: ProcessOperationRequest): Promise<runtime.ApiResponse<ProcessResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/#process`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ProcessRequestToJSON(requestParameters.processRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ProcessResponseFromJSON(jsonValue));
    }

    /**
     * Publish block to the network
     */
    async process(requestParameters: ProcessOperationRequest): Promise<ProcessResponse> {
        const response = await this.processRaw(requestParameters);
        return await response.value();
    }

    /**
     * Generates work for block. hash is the frontier of the account or in the case of an open block, the public key representation of the account which can be found with account_key 
     */
    async workGenerateRaw(requestParameters: WorkGenerateOperationRequest): Promise<runtime.ApiResponse<WorkGenerateResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/#work_generate`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: WorkGenerateRequestToJSON(requestParameters.workGenerateRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkGenerateResponseFromJSON(jsonValue));
    }

    /**
     * Generates work for block. hash is the frontier of the account or in the case of an open block, the public key representation of the account which can be found with account_key 
     */
    async workGenerate(requestParameters: WorkGenerateOperationRequest): Promise<WorkGenerateResponse> {
        const response = await this.workGenerateRaw(requestParameters);
        return await response.value();
    }

}
